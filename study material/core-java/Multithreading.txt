Task
-------
the processing of one binary instruction and provide the output by processer is known as task.
Multitasking
-------------
the processing of multiple instruction at a time by processer is called multi tasking
multi tasking is two types 
1.thread based multi tasking(multi threading)
2.process based multitasking(multi tasking)

process based multi tasking
-----------------------------
when pocesser executing mulple module of same or different application at a time called process based
multitasking.
the running module inside RAM is known as process.

* to keep track of each process stored inside RAM os maintain saperate PCB(process control block)
  mean the multi processing maintain by operating system.(logic wriiten by os developer)
* in process based multi tasking context switching is very timem consuming because processer nedd
  to shift between PCB and different programm.
* process is heavy weight mean lot of logic and programm writen in a module




thread based multitasking
----------------------------
when processer exeuting mulple feature of same module at a time to maintain the synchronization
then it is known as multi threading of thread based multi tasking.

The light weight indepandent progrmmes is called thread.
*to keep track of the thread JVM maintain saperate stack for each thread means threads are controlled
 by JVM as per written logic by application developers.
*in thread based multi tasking the context switching is very easy because it is inside same process
 only need to change the stack space.
* thread is light weight , mainly somem collections of methods

context switching
----------------------
the change of execution of one catagory information to another catagory information is called context 
switching

threads in java application is created and maintained by java developers.

The process of creating thread
------------------------------
there are two approach to create thread
    a. extending Thread class
    b. implementing runnable interface



Thread hierarchy
-------------------
thread hierarchy starts with a interface called Runnable which having a abstract method 
that is run().

class Thread is implementing class of Runnable and having multple method to maintain thread.
the importent method of thread class is run(), start(),join(),sleep(),yield() etc

run() method is known as the logical defination of thread because the logic written inside
run methd going to execute by that user defined thread.

steps to create thread by using Thread class
-----------------------------------------------
1. make a class extending Thread class.
2. overrirde run method() which callled business method of thread
3. call start() method - start() preperes the stack for newly requested thread and call run()
   method , means start() have the capability to create one thread thatwhy start method is known as
   heart of thread
   start() is method of thread class .

* if we call only run() by using object reference then it is just a normal method call
  not a thread creation
*if we call start() multiple time then IllegalThreadStateException will create.
* exception in one thread will not effect to other thread because each thread uses saperate stack
  memory
* main thread is a thread generated by JVM responsible to execute main() method and method called my 
  main()
* the thread called start() method is known as parent thread.

public class MyThread extends Thread{
	
	@Override
	public void run() {
		for(int i=1;i<=20;i++)
			System.out.println("user defined thrad "+i);
	}

}

public class Demo {
	
public static void main(String[] args) {
		
		MyThread t1=new MyThread();
		t1.start();
		
		for(int i=1;i<=20;i++)
			System.out.println("main thread "+i);
	}

}


Creating thread by implementing Runnable interface
--------------------------------------------------
1. create a class implementing runnable interface and override run() methood , run method the
   logical code will execute by thread
2. create a thread object taking Runnable type object as input.
3. call start() of thread type object
Note- only start() method of Thread class have the capability to create a thread at run time

public class MyThread implements Runnable{

	@Override
	public void run() {
		for(int i=1;i<=20;i++)
			System.out.println("user defined thrad "+i);
		
	}

}
public class Demo {
	
	public static void main(String[] args) {
		
		MyThread t1=new MyThread();
		Thread starter= new Thread(t1);
		starter.start();
		
		for(int i=1;i<=20;i++)
			System.out.println("main thread "+i);
	}

}

how to get the object reference of current executing thread
-----------------------------------------------------------
Threre is a method in thread class currentThread() , which is a static method used to find out 
the current executing thread

public class Demo {
	public static void main(String[] args) {
		Thread t=Thread.currentThread();
		System.out.println(t);
	}

}


Thread name
------------------
1. non static method getName() used to retrive the name of a thread in form of String
2. non static memthod setName(String) used to assign the name of the thread
every thrad got a name from jvm by fault.

public class Demo {
	public static void main(String[] args) {
		Thread t=Thread.currentThread();
		String name=t.getName(); //get the name of the thread
		
		System.out.println(name);
		t.setName("jspider-qspider"); //set the name of the thread
		name=t.getName();
		System.out.println(name);
	}

}

Thread priority
---------------
*priority is number by which jvm decides how fast the thread going to get response from JVM.
*JVM used a range of priority 1 to 10 ,10-high priority , 1-low priority
* non static method getPriority() is used to get the priority of a thread in from of int value
* non static method setPriority(int) is uded to update the priority of of a thread.
* if the given argument in setPriority() is not in range of [1,10] then we will get exception.

public class Demo {
	public static void main(String[] args) {
		Thread t=Thread.currentThread();
		int priority=t.getPriority();
		System.out.println(priority);
		t.setPriority(19);
		priority=t.getPriority();
		System.out.println(priority);
	}

}

jvm only assigned priority to main thread and that is 5,  rest all user defined thread collects 
priority from parent thread (mean same as parent thread)

public class MyThread extends Thread{
	
	@Override
	public void run() {
		System.out.println("user defined thread priority "+ this.getPriority());
	}

}

public class Demo {
	public static void main(String[] args) {
		Thread t2=Thread.currentThread();
		t2.setPriority(9);
		MyThread t1=new MyThread();
		t1.start();
		System.out.println("main thread as parent priority "+ t2.getPriority());
	}

}

* windows operating system does not support priority based thread modeling, for that different plugin 
  of windows need to install- but the installed windows should be licenced version.

green thread model
---------------------
when operating system allows the JVM to execute thread in RAM without permission of OS is called green
thread model. eg- sun-solaris
but in present days green thread model not used in OS because of data security problem.


Daemon Thread
--------------
Before start execution of programm jvm generates some predined thread to help other thread execution
these thread is known as daemon thread or helper thread.
Some times these threads are executes thatwhy daemon thread is always low priority thread, but when
the daemon thread need to execute the jvm set the priority very high of deamon thread. once the non
daemon thread execution complete then the daemon thread execution stops by jvm(destroys the deamon thread)

* all main thread and user defined thread are non daemon thread by dafult, but user defined thread we can 
  change the daemonness.

one non static method in Thread class isDaemon() which return true if the thread is daemon or return false
public class Demo {
	public static void main(String[] args) {
		MyThread t1=new MyThread();
		Thread t2=Thread.currentThread();
		System.out.println(t1.isDaemon());
		System.out.println(t2.isDaemon());
	}

}

*programmer can chage the daemonness of a thread by using setDeamon(boolean) method , but only before the
 start execution of the thread otherwise Exception
public class MyThread extends Thread{
	
	@Override
	public void run() {
		for(int i=1;i<=20;i++)
		{
			System.out.println("user defined thread "+i);
		}
	}

}

public class Demo {
	public static void main(String[] args) {
		MyThread t1=new MyThread();
		t1.setDaemon(true);
		t1.start();
		for(int i=1;i<=5;i++)
		{
			System.out.println("main thread "+i);
		}
		
		
	}

}


sleep() method  in multi threading
----------------------------------------
sleep() method is a static method of Thread class used to make a thread temporary idle. so that the
thread execution paused for some times. once the sleeping time over then the resume of execution started.
sleep() throws InterruptException which is checked exception (means either we need to handle it or thows it)

the overloaded forms are 
sleep(long milisecond) throws InterruptException
sllep(long milisecond,long nanosecond) throws InterruptException

public class Demothread1 {
	public static void main(String[] args) throws InterruptedException {
		for(int i=1;i<=10;i++)
		{
			System.out.println("main thread "+i);
			Thread.sleep(2000,200); 
		}
	}

}


yield() method
-------------------------------
it it a static method of Thread class. it it used to pause the execution of current thread and start the 
execution of other waiting high priority thread then current executing thread.
once the high priority thead execution completed then it comes the paused thread.\

it does not throes any excpetion because the waiting high priority thread going to execute or not depended
on the thread scheduler(if underlying Operating system works on priority based algorithm ).
thatwhy in windows system yield() not works.

public class DemoThread2 {
	public static void main(String[] args) {
		
		MyThread t1=new MyThread();
		t1.setPriority(8);
		t1.start();
		Thread.yield();
		for(int i=1;i<=10;i++)
		{
			System.out.println("main thread "+i);
		}
		
	}

}

class MyThread extends Thread{
	@Override
	public void run() {
		for(int i=1;i<=10;i++)
		{
			System.out.println("user defined thread " + i);
			try {
				Thread .sleep(1000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
		}
	}
}

join() method
------------------
join() method is a non static method of Thread class used to deliver sequential execution.
driving licence considers as main thread then the documentation, test drive and medical repost need to
be done in sequence manner .

the caller thread calling join method waits till the thrad complete tast to whom we called the join method()

public class License {
	public static void main(String[] args) throws InterruptedException {
		
		System.out.println("licence procudure started");
		Documentation d=new Documentation();
		TestDrive t=new TestDrive();
		MedicalTest m=new MedicalTest();
		d.start();
		d.join();
		t.start();
		t.join();
		m.start();
		m.join();
		System.out.println("Licence got");
		
	}

}
class Documentation extends Thread
{
	@Override
	public void run() {
		System.out.println("documentation complete");
		try {
			Thread.sleep(2000);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}
}
class TestDrive extends Thread
{
	@Override
	public void run() {
		System.out.println("testdrive done");
		try {
			Thread.sleep(2000);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}
}
class MedicalTest extends Thread{
	@Override
	public void run() {
		System.out.println("medical test done");
		try {
			Thread.sleep(2000);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}
	
}

Data inconsistency
-----------------------
when multiple thread going to access same data at a time then data inconsistency problem may happen durin data
overwriring time. 
the solution for data inconsistency is synchronization, the synchronization indicates that at a time only one thread 
aloowd to access the data.

to achive synchronization java provides a keyword called synchronized. the method prefixed with synchronized
can not access by multiple thread at a time , mean all thread going to access one by one , when one thread aceessing
synchronized method that time other method is in waiting state.

public class Demo {
	
	public synchronized void m1() 
	{
		for(int i=1;i<=10;i++)
		{
			System.out.println("i="+i+" "+ Thread.currentThread().getName());
			try {
				Thread.sleep(500);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
		}
	}

}

public class MyThread extends Thread{
	
	Demo d;

	public MyThread(Demo d) {
		super();
		this.d = d;
	}
	@Override
	public void run() {
		d.m1();
	}

}

public class MainThread {
	public static void main(String[] args) {
		Demo d=new Demo();
		MyThread m=new MyThread(d);
		m.setName("User defined thread");
		m.start();
		d.m1();
	}

}


internal flow of synchronized keyword
-------------------------------------------
each object have a lock assigned vy jvm. once any thread want to execute the synchronized method of one object
then the thread need to manage the lock from jvm. once lock assign to one thread , then till execution
of synchronized method the lock hold by assignmed thread , once lock relesed then only other thread going to execute
the synchronized block. to access non synchronized method no lock nneded. and the lock is one for each objecect
not for method.

similarly there is class level lock only used to access the static synchronized method of a class, this type
of lock is only one at a class level.













class level lock demo programm
-----------------------------------
public class Demo {
	
	public static synchronized void m1() 
	{
		for(int i=1;i<=10;i++)
		{
			System.out.println("i="+i+" "+ Thread.currentThread().getName());
			try {
				Thread.sleep(500);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
		}
	}

}
public class MyThread extends Thread{
	
	
	@Override
	public void run() {
		Demo.m1();
	}

}
public class MainThread {
	public static void main(String[] args) {
		MyThread m=new MyThread();
		m.setName("User defined thread");
		m.start();
		Demo.m1();
	}

}



Thread life cycle
-----------------------

new or born state
------------------------
when programmer create the object of one Thread is called new or born thread
eg-01  MyThread t1=new MyThread();

eg-02  Runnable r=new MyThread2()
       Thread t2= new Thread(r); 
       Here MyThread2 is a implementation class of Runnable

runnable
-----------
this is the state where start memthod called , and waits for OS to allocate memory in RAM

running
----------
it is the state when run() method logic executing

dead
------
when all the work done by thread mean no logic pendiing then it destroyes 

waiting/sleep/stop/pause
-------------------------
for some time or permanently the thrad is in idle state

Inter thread communication
------------------------------
The information exchange or the communication between two threads for smooth execution of
program called inter thread communication.
eg- producer and consumer problem

for interthread communication programmer mainly used two method of object class that is
notify() and wait() method

wait() is used to make wait current executing thread under a certain condition.once wait() 
method called the thread relesed the lock so that other thread going to access the object

the notify() method informs all the waiting thread that the object is now ready for all 
kind of operations.

both wait() andn notify() works under synchronized area

public class Account {
	int balance;

	public Account(int balance) {
		super();
		this.balance = balance;
	}
	
	public synchronized void  withdraw(int ammount) throws InterruptedException
	{
		if(ammount >balance) {
			System.out.println("tranction pending due to insufficiant balance");
			wait();
		}
		
		balance-=ammount;
		System.out.println("after withdraw the balance is "+balance);
	}
	public synchronized void diposite(int ammount) throws InterruptedException
	{
		balance += ammount;
		Thread.sleep(2000);
		System.out.println("after diposite the balance "+balance);
		notify();
	}
	

}

public class AccountManager extends Thread{
	Account ac;

	public AccountManager(Account ac) {
		super();
		this.ac = ac;
	}
	@Override
	public void run() {
		try {
			ac.withdraw(5000);
		} catch (InterruptedException e) {
			
			e.printStackTrace();
		}
	}

}
public class DemoInterthreadCommunication {
	public static void main(String[] args) throws InterruptedException {
		Account ac=new Account(3000);
		AccountManager acm=new AccountManager(ac);
		acm.start();
		Thread.sleep(2000);
		ac.diposite(3000);
		
	}

}

Deadlock
-----------------
when multiple threads waiting for each other to be complete , but no one is going to 
complete because of inter dependency and synchronized , this situation is known as
deadlock.
Dead lock is like infinite waiting without any solution, deadlock have no solution
the only approach is to prevent dedlock. deadlock happened only in sychronized area.
in synchronized area multiple thrad can access at a time mean there is no dead lock kind
of situation without synchronized, thatswhy it is not recomanded to used synchronied
without specific reason

public class A {
	
	public synchronized void m1(B b)
	{
		System.out.println("Thread 1 strted exeution of A class m1()");
		try {
			Thread.sleep(6000);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		b.d2();
	}
	
	public synchronized void d1()
	{
		System.out.println("A class d1() method");
	}

}

public class B {
	
	
	public synchronized void m2(A a)
	{
		System.out.println("Thread 2 strted exeution of B class m2()");
		try {
			Thread.sleep(6000);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		a.d1();
	}
	
	
	public synchronized void d2()
	{
		System.out.println("B class d2() method");
	}

}

public class DemoDeadLock extends Thread{
	
	A a=new A();
	B b=new B();
	
	@Override
	public void run() {
		b.m2(a);
	}
	public void helper() {
		this.start();
		a.m1(b);
		
	}
	
	public static void main(String[] args) {
		
		DemoDeadLock d=new DemoDeadLock();
		d.helper();
		
	}

}



















